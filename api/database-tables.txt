-- Use an ENUM type for roles for better data integrity.
CREATE TYPE user_role AS ENUM ('user', 'admin');

CREATE TABLE IF NOT EXISTS users (
  id              SERIAL PRIMARY KEY,
  full_name            VARCHAR(255) NOT NULL,
  preferred_name       VARCHAR(100),
  email           VARCHAR(255) UNIQUE NOT NULL,
  password_hash   TEXT, -- null if OAuth-only account
  role            user_role NOT NULL DEFAULT 'user',
  is_verified     BOOLEAN NOT NULL DEFAULT FALSE,
  is_disabled     BOOLEAN NOT NULL DEFAULT FALSE, -- Added for disabling accounts
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  password_updated TIMESTAMPTZ, -- Nullable; set whenever the user changes or sets a password
  last_login      TIMESTAMPTZ,
  metadata        JSONB
);



-- Use an ENUM type for token types to make the table more versatile.
CREATE TYPE token_type AS ENUM ('email_verification', 'password_reset');

CREATE TABLE IF NOT EXISTS verification_tokens (
  id              SERIAL PRIMARY KEY,
  user_id         INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token           VARCHAR(255) NOT NULL UNIQUE,
  token_type      token_type NOT NULL, -- Added to support different token uses
  expires_at      TIMESTAMPTZ NOT NULL,
  used            BOOLEAN NOT NULL DEFAULT FALSE,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

---

CREATE TABLE IF NOT EXISTS oauth_accounts (
  id               SERIAL PRIMARY KEY,
  user_id          INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  provider         VARCHAR(50) NOT NULL, -- e.g. 'google', 'github'
  provider_user_id VARCHAR(255) NOT NULL, -- The unique ID from the provider
  access_token     TEXT,  -- IMPORTANT: Encrypt this value before storing!
  refresh_token    TEXT,  -- IMPORTANT: Encrypt this value before storing!
  scopes           JSONB, -- Optional: Store granted OAuth scopes
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(provider, provider_user_id)
);

bookdb=> SELECT * FROM oauth_accounts;
 id | user_id | provider | provider_user_id | access_token | refresh_token | scopes | created_at | updated_at
----+---------+----------+------------------+--------------+---------------+--------+------------+------------
(0 rows)

---

CREATE TABLE IF NOT EXISTS refresh_tokens (
  id                SERIAL PRIMARY KEY,
  user_id           INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_fingerprint VARCHAR(128) NOT NULL UNIQUE,
  issued_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at        TIMESTAMPTZ NOT NULL,
  revoked           BOOLEAN NOT NULL DEFAULT FALSE,
  ip_address        INET, -- Added for security auditing
  user_agent        TEXT  -- Added for security auditing
);

CREATE TABLE IF NOT EXISTS book_types (
  id                SERIAL PRIMARY KEY,
  user_id           INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name              VARCHAR(100) NOT NULL,
  description       TEXT,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, name)
);

CREATE TABLE IF NOT EXISTS dates (
  id          SERIAL PRIMARY KEY,
  day         INT,
  month       INT,
  year        INT,
  text        VARCHAR(100) NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  CHECK (day IS NULL OR (day BETWEEN 1 AND 31)),
  CHECK (month IS NULL OR (month BETWEEN 1 AND 12)),
  CHECK (year IS NULL OR (year BETWEEN 1 AND 9999)),
  CHECK (day IS NULL OR month IS NOT NULL),
  CHECK (month IS NULL OR year IS NOT NULL)
);

CREATE TABLE IF NOT EXISTS authors (
  id             SERIAL PRIMARY KEY,
  user_id        INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  display_name   VARCHAR(150) NOT NULL,
  first_names    VARCHAR(150),
  last_name      VARCHAR(100),
  birth_date_id  INT REFERENCES dates(id) ON DELETE SET NULL,
  deceased       BOOLEAN NOT NULL DEFAULT FALSE,
  death_date_id  INT REFERENCES dates(id) ON DELETE SET NULL,
  bio            TEXT,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, display_name)
);

CREATE TABLE IF NOT EXISTS publishers (
  id              SERIAL PRIMARY KEY,
  user_id         INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name            VARCHAR(150) NOT NULL,
  founded_date_id INT REFERENCES dates(id) ON DELETE SET NULL,
  website         VARCHAR(300),
  notes           TEXT,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, name)
);

CREATE TABLE IF NOT EXISTS book_authors (
  id         SERIAL PRIMARY KEY,
  user_id    INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  book_id    INT NOT NULL,
  author_id  INT NOT NULL REFERENCES authors(id) ON DELETE CASCADE,
  role       VARCHAR(100),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, book_id, author_id)
);

CREATE TABLE IF NOT EXISTS book_series (
  id             SERIAL PRIMARY KEY,
  user_id        INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name           VARCHAR(150) NOT NULL,
  start_date_id  INT REFERENCES dates(id) ON DELETE SET NULL,
  description    TEXT,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, name)
);

CREATE TABLE IF NOT EXISTS book_series_books (
  id         SERIAL PRIMARY KEY,
  user_id    INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  series_id  INT NOT NULL REFERENCES book_series(id) ON DELETE CASCADE,
  book_id    INT NOT NULL,
  book_order INT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, series_id, book_id)
);

CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = now();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_modtime
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_oauth_accounts_modtime
BEFORE UPDATE ON oauth_accounts
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_book_types_modtime
BEFORE UPDATE ON book_types
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_dates_modtime
BEFORE UPDATE ON dates
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_authors_modtime
BEFORE UPDATE ON authors
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_publishers_modtime
BEFORE UPDATE ON publishers
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_book_authors_modtime
BEFORE UPDATE ON book_authors
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_book_series_modtime
BEFORE UPDATE ON book_series
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_book_series_books_modtime
BEFORE UPDATE ON book_series_books
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();


-- Recommendation: Add indexes for common query patterns.
-- Speeds up finding all logs for a specific user.
CREATE INDEX idx_user_logs_user_id ON user_logs(user_id);
-- Speeds up finding all logs of a certain type (e.g., all failed logins).
CREATE INDEX idx_user_logs_action_status ON user_logs(action, status);
-- Speeds up sorting by time.
CREATE INDEX idx_user_logs_created_at ON user_logs(created_at);
